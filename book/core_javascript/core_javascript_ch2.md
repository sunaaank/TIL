# 코어자바스크립트 2장 복습용 질문리스트

- 실행 컨텍스트란?
- 실행 컨텍스트가 활성화 되는 시점에 하는 3가지 동작
- 스택과 큐의 차이
- variableEnvironment, lexicalEnvironment가 뭔지와 차이
- variableEnvironment과 lexicalEnvironment가 수집하는 정보 2가지
- environmentRecord와 호이스팅
    - environmentRecord가 변수 정보를 수집하면서 실행되는게 호이스팅
- 호이스팅 규칙
- 함수 선언문과 함수 표현식 차이 (호이스팅도 같이 설명할 수 있어야함)
- 함수 선언문, 익명 함수 표현식, 기명 함수 표현식 어떻게 쓰는지
- 함수 선언문으로 할 경우 어떤 문제점이 발생하는지
- 스코프, 스코프 체인이 무엇인지
- ES5와 ES6이후의 스코프 차이
- 스코프 체인을 가능하게 하는 수집 자료
- outerEnvironmentReference가 lexicalEnvironment를 참조하는 순간
- p.54 코드 4번째줄 `console.log(a)` 가 undefined 인 이유
- p.54 코드에서 전역변수와 지역변수가 무엇인지
- p.54 코드를 p.57의 표로 설명
- 호이스팅을 변수 선언, 값 할당, 함수 선언문, 함수 표현식을 넣어서 설명해보기 (p.64)


## 책 질문

### ✨실행 컨텍스트란?

    > 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 실행컨텍스트가 활성화 될때마다 수집한 [호이스팅된 변수객체, 스코프체인, this 바인딩]에 대한 환경정보를 담고 있다.

    1.전역 컨텍스트 최초 생성 후에 함수 호출할 때마다 실행 컨텍스트가 생성

    2.컨텍스트 생성시에 변수객체, 스코프 체인, this가 생성된다.

    3.컨텍스트 생성 후 함수가 실행되는데 함수에서 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 스코프체인을 따라 올라가며 찾음.

    4.함수 실행이 마무리되면 해당 컨텍스트는 사라짐. 페이지가 종료되면 전역 컨텍스트가 사라짐

### ✨실행 컨텍스트가 활성화 되는 시점에 하는 3가지 동작 (대표적인)

    > 호이스팅, 스코프체인(외부환경정보 수집), this 값 설정(바인딩)

### ✨스택과 큐의 차이

    실행컨텍스트는 스택의 형태. ⇒ 콜스택

    스택은 후입선출로, 쌓아 올리는 구조

    큐는 선입선출로, 줄서듯 통로를 지나가는 구조

- variableEnvironment, lexicalEnvironment가 뭔지와 차이
    - 둘다 environmentRecord와 outerEnvironmnetReference로 구성된다.(선언한 변수, 외부환경정보 수집) 초기화 과정에는 동일하고, 이후 코드 진행에 따라 달라지게 된다.
    - 실행컨텍스트 생성 시 먼저 variableEnvironment에 최초실행시 스냅샷을 담는다.
    - 이를 복사해서 lexicalEnvironment에 담고 이걸 주로 활용한다.
### ✨variableEnvironment과 lexicalEnvironment가 수집하는 정보 2가지
    - environmentRecord: 현재 컨텍스트와 관련관 코드의 식별자 정보(함수-매개변수 식별자, 함수선언문-함수 그 자체, 변수-변수의 식별자)
    - outerEnvironmnetReference-외부환경정보(스코프체인)

### ✨environmentRecord와 호이스팅
    > environmentRecord가 변수 정보를 수집하는 과정이 호이스팅

    - 변수 생애주기 : 선언-초기화-할당
    - 변수를 호이스팅할 때 변수명만 끌어올리고 할당과정은 그대로 둠.
    - 호이스팅: 변수의 선언에만 관심이 있고, 할당 과정에는 관심이 없음.

- ✨호이스팅 규칙

    > 변수를 선언하고 초기화 했을때 선언부분이 최상단으로 끌어올려지는 현상

    예를들어, 코드 상단에서 console.log(a)를 찍고 하단에서 var a=1; 이라고 하였을때 a는 undefined라고 나온다. 이런 현상을 호이스팅이라고한다. let이나 const를 쓸 경우에는 변수 선언시에 초기화가 이루어지지 않아 변수 선언 위에서 a 자체를 찾을 수 없다. 함수의 경우 함수표현식은 호이스팅이 적용되지 않으나 일반 함수선언문은 함수 호이스팅이 적용된다.

### ✨함수 선언문과 함수 표현식 차이 (호이스팅도 같이 설명할 수 있어야함)

    > 둘 다 함수를 새롭게 정의할 때 쓰는 방식. 함수 선언문으로 함수를 정의할 경우, 함수 전체가 호이스팅 되며, 함수 표현식으로 함수를 정의할 경우 변수명만 호이스팅됨

    ```jsx
    function a() { console.log("함수 전체 호이스팅됨") } // 함수 선언문

    const b = function() { console.log("변수명만 호이스팅됨") } // (익명) 함수 표현식 
    const c = function d() { console.log("변수명만 호이스팅됨") } // 기명 함수 표현식
    ```

    - 함수 선언문 : function 정의부만 존재(반드시 함수명 정의 필요), 별도의 할당명령 없음.
    - 함수 표현식 : 정의한 function을 별도의 변수에 할당함.
        - 함수명을 정의하면 기명함수 표현식, 정의하지 않으면 익명함수 표현식
#### 함수 선언문으로 할 경우 어떤 문제점이 발생하는지

    > 함수선언문은 함수 전체를 호이스팅해서, 가장 마지막에 할당한 값으로 오버라이딩이 일어나며, 마지막에 선언한 함수만 실제로 호출됨.** 원활한 협업을 위해서는 전역공간에 함수 선언하거나 동명의 함수를 중복선언(오버라이딩) 하는 일이 없어야 함. 만에하나 동명의 함수가 전역공간에 있다고 해도 **함수표현식으로 정의돼있다면 함수 전체가 호이스팅되어 나중에 할당한 값이 먼저 할당한 값을 오버라이딩해, 실제로 호출되는 함수가 오직 마지막에 할당한(선언한) 함수가 되는 일은 발생하지는 않음.

### ✨스코프, 스코프 체인이 무엇인지
    > - 스코프 : 식별자의 유효범위. A 스코프 내부에서 선언한 변수는 A 스코프 내부에서만 접근할 수 있음.
    
    > - 스코프체인 : '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것. (식별자 중에서 객체의 프로퍼티가(프로토타입체인)가 아닌 식별자, 즉 변수를 검색하는 매커니즘.)
    - 스코프체인은 Lexical Environment에서 외부환경정보를 수집(현재 호출된 함수가 선언될 당시의 Lexical Environment를 참조함) 했기에 가능함.

### ✨ES5와 ES6이후의 스코프 차이
    > - ES6에서 블록스코프가 생김. let, const, class, strict mode에서의 함수선언 등에 대해서만 블록스코프 범위가 생김.
    - ES6에서는 이전과 이후를 구분하기 위해 함수 스코프, 블록 스코프라는 용어를 씀

#### 스코프 체인을 가능하게 하는 수집 자료
    - ES6에서는 이전과 이후를 구분하기 위해 함수 스코프, 블록 스코프라는 용어를 씀
    - outerEnvironmentReference가 lexicalEnvironment를 참조하는 순간

    현재 호출된 함수가 선언될 당시의 Lexical Environment를 참조함

### p.54 코드 4번째줄 `console.log(a)` 가 undefined 인 이유
    - 식별자 a가 호이스팅 되었는데 아직 할당된 값이 없음.
    - 스코프 체인은 안쪽부터 검색해나가는 것이기 때문에, 이미 a를 발견했으므로, 스코프 체인 검색을 더이상 진행하지 않음. 전역공간에서 선언한 동일한 이름의 a 변수에는 접근할 수 없음. (⇒ 변수 은닉화)