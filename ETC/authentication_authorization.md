## 인증과 인가

인증과 인가는 자원을 적절한/유효한 사용자에게 전달/공개하기 위한 방법

### 인증(Authentication)이란

- 예시 : (닉네임과 사진 같은 정보로) 프론트데스크에서 구글 사원인지 입증하는 과정
- 적용 : 보호된 리소스에 접근하는 것을 허용하기 이전에 (식별가능한 정보로) 서비스에 등록된 유저의 신원을 입증하는 과정

### 인가(Authorization)란

- 예시 : 구글 게스트 출입증으로 1층은 접근할 수 없지만 근무 공간에는 접근할 수 없다는 권한 확인
- 적용 : 인증된 사용자에 대한 요청된 자원 접근 권한 확인

### 웹에서의 인증과 인가

- 인증 : 회원가입을 하고 로그인을 함
  => 인가도 포함됨(글을 읽고 쓸 수 있는 권한이 생김, 다른 사람의 글은 수정할 수 없음.)

## 인증과 인가 방법

- 선행되어야 하는 것은 `인증`
- `인가`가 `인증`보다 나중에 나온 개념
  (보안과 사용자의 편의성 사이에서 밸런스를 잡기 위한 과정 아닐지... 프로그래밍에는 정답이 없고 주어진 요구사항에 맞춰서 구현하는 것이 최적이다)

1. 인증하기 - Request Header
2. 인증 유지하기 - Browser
3. 안전하게 인증하기 - Server
4. 효율적으로 인증하기 - Token
5. 다른 채널을 통해 인증하기 - OAuth

### 사전 지식

클라이언트와 서버가 HTTP를 통해 통신

- HTTP는 무상태성(Stateless) 특징을 가지고 있음. 서버는 클라이언트가 온 요청과 그 다음 요청과 연관관계가 없다고 생각을 하고, 다음 요청을 받고 처리함.

### 1. Request Header 활용하기

- http://www.google.com/login이라는 URL에서 Base64라는 인코더를 이용해서 인코딩을 한 이후에 전달해주는 방식
- http://user:1q2w3e4r!@www.google.com/login
- URL에서 user, 1q2w3e4r! 부분을 파싱한 후, 인코더를 통해서 인코딩한 문자열을 요청 헤더에 Authorization에 넣어 보내주는 것
- 서버로 보내주고 DB에 해당 유저데이터가 있으므로 200OK를 보내주면 로그인이 됨

=> 문제점 : 매번 사용자가 인증(로그인)을 해주어야 함 (글을 쓸 때 로그인을 했음, 수정을 하고 싶은데 인증 요청을 또 해야함)
=> 해결방안 : 브라우저 Storage의 도움을 빌림

### 2. Browser 활용하기

(Local Storage, Session Storage, Cookie 활용 가능)

- 인증이 필요한 요청을 할 때 꺼내서 서버로 같이 보내주면 됨
- 사용자 입장에서 편리, 해커 입장에서도 편리함
  => 문제점 : Storage에 로우하게 사용자 정보가 노출되어 있으니 가져가기 편리함, 클라이언트가 서버보다 상대적으로 보안에 취약하다는 단점이 있음
  => 해결 방안 : 서버에 도움을 요청함

### 3. 안전하게 인증하기 - Session 활용하기

- 세션 : 인증된 사용자의 식별자와 랜덤한 문자열로 세션 id를 만들어서, 이를 응답의 헤더로 넘겨주고 클라이언트가 저장할 수 있도록 만드는 것
- 장점1 : 클라이언트 측에서 사용자의 로우한 데이터를 가지고 있지 않아, 해커가 정보를 가져가도 크게 위험하지 않음.
- 장점2 : 세션의 만료기간을 정할 수 있음. 만료기간이 지날 경우, 유효하지 않은 데이터가 됨.
- 장점3 : 세션 관리를 서버에서 하고 있어, 탈취한 세션에 대한 정보를 서버에서 지우면 세션을 이용할 수 없게 된다는 보안상의 이점이 있음.
  => 문제점1 : 서비스가 커져서 서버가 여러개 있을 경우, [로드밸런서](https://medium.com/harrythegreat/aws-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-9fd0955f859e0)(한 곳의 엔드포인트로 들어오는 트래픽을 각 인스턴스에 분산시켜주는 분산처리시스템)가 다른 서버로 인증을 보내면 오류가 생김. 서버 하나하나 자체에서 세션을 관리하고 있어서 생긴 문제.
  => 해결방안1 : 세션스토리지를 따로 만들어서 관리함.
  => 해결방안1의 문제점 : 유저가 많아지면 서버가 터짐

===> 1,2,3 방법의 문제점 : 클라이언트, 서버, 세션저장소 세 곳에 모두 사용자의 상태를 관리할 수 있도록 하였지만, 문제가 생겼음.
===> 문제 발생 이유 : 통신을 할 때 사용하는 HTTP와 서버가 지향하는 RestfulAPI가 무상태성을 기초로 하기 때문임. 실제로 인증인가를 할 때는 사용자의 정보를 가지고 있었음. 상태성을 가지고 있다는 의미. 두 패러다임이 충돌을 하고 있음.
===> 해결방안 : 정보의 요청과 응담(contents)안에 사용자의 상태를 담아보자. 그거로만 인증과 인가를 처리해보자. Token을 활용한 인증인가 방법이 생김.

### 4. 효율적으로 인증하기 - Token

- JWT(JSON WEB TOKEN) : 시크릿키를 사용해 JWT를 만들어냄. 시크릿키를 사용해 JWT의 인증과정을 거침.
- JWT 자체는 해독하기가 무척 쉬움. 비밀번호 등의 민감한 정보는 담지 않음. 시크릿키를 서버 내부에서 잘 관리해야 함.

- 토큰이 클라이언트에서 서버로 넘어감.
- 서버는 본인이 가진 시크릿키로 이 토큰의 유효성 검사를 진행함.
- 유효하다면, 사용자 정보를 파악함.(이름, 만료시기, 권한) => 만료된 토큰이거나, 권한이 없는 토큰이면 유효하지 않다는 요청을 반환함.
- 세션DB를 따로 둘 필요 없이, 로드밸런서가 쏘는 곳에서 각자 시크릿 키로 해독해서 인증을 진행하고 요청을 반환하면 됨.(확장성과도 연관됨)
  => 문제점1 : Access Token을 탈취당하면 해킹을 당하기 쉬움.
  => 해결방안1 : 만료기한을 정해둠.
  => 해결방안1의 문제점 : 사용자도 불편해짐
  => 해결방안 : Refresh Token을 사용함.

  #### Refresh Token

  - 보낸 로그인 요청에 따라 시크릿키를 만들어냄.
  - Access Token과 Refresh Token을 한번에 만들어냄.
  - Access Token은 저장하지 않고 Refresh Token만 저장함.
  - 이 둘을 한번에 응답의 헤더로 보내고, 클라이언트가 둘 다 저장하게 됨.
  - Access Token이 만료되면, 서버는 만료되었다고 함. 브라우저가 Refresh Token과 함께 다시 보냄. 서버는 새로 갱신한 Access Token을 보냄.

  ===> 핵심 :

  - 장점 : 토큰으로 상태관리를 하기에 따로 세션을 둘 필요가 없음. 효율성이 좋아지고 속도가 조금 빨라짐.
  - 단점 : 토큰도 관리해야 하는 대상임. 보안에 대해서는 꾸준히 신경써야 함.

### 5. 다른 채널을 통해 인증하기 - OAuth

#### OAuth란?

- 구글/페이스북/네이버/깃헙/카카오 로그인 등이 자체가 아니라, 이 로그인에서 사용하는 인증절차를 OAuth라고 함.

- 장점1 : (사용자) 사용자는 서비스에 ID/PW를 알려주지 않아도 됨. 원할 때 엑세스 토큰의 권한 취소가 가능함.
- 장점2 : (서비스) 유저의 액세스 토큰만 가지고 있으면 됨. 사용자의 ID/PW를 몰라도 허가 받은 API 접근 가능함.

#### OAuth 사용과정

(OAuth 인증 과정)

- 유저 브라우저가 OAuth 제공자(구글)에게 버튼 눌렀다고 요청함.("로그인 버튼 눌렀어")
- OAuth제공자(구글)은 응답함.("우리 회원이니?")
- 유저 브라우저가 OAuth 제공자에게 로그인 정보를 보냄("응 여기")
- OAuth 제공자가 리다이렉트 되면서 코드를 반환해줌
- 유저 브라우저가 서버로 query param에 code가 있으면 요청을 보냄.
- 서버는 OAuth제공자(구글)에게 유저 브라우저가 준 코드로 엑세스 토큰을 요청함.("엑세스 토큰 주세요 with code")
- OAuth제공자는 서버에게 Access Token을 줌("응 가져가")

(여기부터는 OAuth로 API이용 과정)

- 유저 브라우저에서 서버에 어떤 요청을 보냈을 때, 서버는 OAuth제공자에게 요청을 보냄("어떤거 해달래! with 액세스 토큰")
- OAuth제공자는 요청에 맞는 것을 하고 응답해줌. 리소스를 보내줌.
- 서버는 유저브라우저에게 응답을 보내줌.

#### OAuth 2.0

클라이언트가 다른 사용자 대신 특정 리소스에 접근을 요청할 때 사용

#### 1.0 VS 2.0?

1. 인증절차 간소화

- 기능 단순화 및 규모 확장성 지원을 위해 디지털 서명 기반의 암호화 => HTTPS의 암호화에 맡김

2. 용어 변경
3. 다양한 인증 방식 제공

- 6가지 방식 제공

### 더 알아보려면 (키워드)

- 보안
- JWT
- OAUTH
- 인증 서버
- HTTPONLY 옵션 (서버에서 클라이언트로 정보를 보낼 때, 보내는 정보에 달아주는 옵션. 스토리지에 저장된 정보에 함부로 접근할 수 없도록 하는 옵션)
- Sliding Session
- Refresh Token(써야하나 말아야하나 의견이 분분함)
- SSL / TLS1.3 (가장 접근하기 쉬운 보안방법)
- 해킹 방법(적을 알면 다 이긴다!)

### 자료출처

- [10분 테코톡 | 토니의 인증과 인가](https://youtu.be/y0xMXlOAfss)를 듣고 정리한 내용입니다.
- [10분 테코톡 | 루피의 인증과 인가](https://youtu.be/JZgD8aPkHSc)를 듣고 정리한 내용(OAUTH)입니다.
